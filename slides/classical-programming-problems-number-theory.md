# 经典编程题

数论相关

		
# 质数

- 质数（prime number）是指一个大于 1 的正整数，除了 1 和自身之外，没有第二个正整数可以整除它。最小的质数是 2。
- 编程找出尽可能多的质数。运行效果如下：

```console
$ ./prime-numbers
2
3
5
7
11
```

		
## 素数筛

- 素数（prime number）是指一个大于 1 的正整数，除了 1 和自身之外，没有第二个正整数可以整除它。最小的质数是 2。
- 素数筛（朴素筛、Eratosthenes 筛和 Euler 筛）的数学原理。
- 使用素数筛算法编程找出 16 位或 32 位无符号整数范围内的质数。运行效果如下：

```console
$ ./prime-numbers-sieve
2
3
5
7
11
13
17
19
23
29
...
65521
65519
65497
65479
65449
65447
65437
65423
65419
65413
Totally 6542 primes (0.000330209 seconds consumed).
```

		
## 素性测试

- 素性测试算法尝试在不分解给定自然数的情况下，确定给定的自然数是否为素数。分为确定性测试和概率测试两类。
- 使用特定的素性测试算法找出 64 位无符号整数范围内的所有质数。运行效果如下：

```console
$ ./primality-test
2
3
5
7
11
13
17
19
23
29
...
65521
65519
65497
65479
65449
65447
65437
65423
65419
65413
Totally 6542 primes (0.000330209 seconds consumed).
```

	
### Fermat 素性测试

1. 依据费马小定理

若 `$ p $` 为素数，且 `$ gcd(a,p)=1 $`，则 `$ a^{p-1} \equiv 1 \ (\mod p) $`。  
或者，若 `$ p $` 为素数，对于任意整数 `$ a $`，有 `$ a^p \equiv a \ (\mod p) $`。

	
### Miller–Rabin 素性测试

1. 是对 Fermat 素性测试的改进，依据另一个有关质数的定理；在假设广义黎曼猜想成立的前提下，只需检查

		
## 亲和数

- 亲和数（amicable pair）是指一对正整数，第一个正整数的所有真因子之和等于第二个正整数，而第二个正整数的所有真因子之和等于第一个正整数。
- 编程找出尽可能多的亲和数。运行效果如下：

```console
$ ./amicable-numbers
220 284
1184 1210
2620 2924
5020 5564
6232 6368
10744 10856
12285 14595
17296 18416
63020 76084
66928 66992
67095 71145
69615 87633
79750 88730
100485 124155
122265 139815
122368 123152
141664 153176
142310 168730
171856 176336
176272 180848
185368 203432
196724 202444
280540 365084
308620 389924
319550 430402
356408 399592
437456 455344
469028 486178
503056 514736
522405 525915
600392 669688
609928 686072
624184 691256
635624 712216
643336 652664
667964 783556
726104 796696
802725 863835
879712 901424
898216 980984
947835 1125765
```

		
## 亲和数的欧拉方法

- 亲和数（amicable pair）是指一对正整数，第一个正整数的所有真因子之和等于第二个正整数，而第二个正整数的所有真因子之和等于第一个正整数。
- 欧拉方法的数学原理。
- 使用欧拉方法编程找出尽可能多的亲和数。运行效果如下：

```console
$ ./amicable-numbers-euler
220 284
1184 1210
2620 2924
5020 5564
6232 6368
10744 10856
12285 14595
17296 18416
63020 76084
66928 66992
67095 71145
69615 87633
79750 88730
100485 124155
122265 139815
122368 123152
141664 153176
142310 168730
171856 176336
176272 180848
185368 203432
196724 202444
280540 365084
308620 389924
319550 430402
356408 399592
437456 455344
469028 486178
503056 514736
522405 525915
600392 669688
609928 686072
624184 691256
635624 712216
643336 652664
667964 783556
726104 796696
802725 863835
879712 901424
898216 980984
947835 1125765
```

		
## 完美数

- 完美数（perfect number）是指其所有真因子之和等于自己的正整数。
- 编程找出尽可能多的完美数。运行效果如下：

```console
$ ./perfect-numbers
6
28
496
8128
```

		
## 自恋数/水仙花数

- 广义上的自恋数（narcissistic number）是指一个 `n` 位数（`n >= 3`）的十进制数，它每位上的数字的 `n` 次幂之和等于它本身。如 <code>371 = 3<sup>3</sup> + 7<sup>3</sup> + 1<sup>3</sup></code>，则 `371` 是一个三位的自恋数。
- 编程找出尽可能多的自恋数（水仙花数）。运行效果如下：

```console
$ ./narcissistic-numbers
153
370
371
407
1634
8208
9474
54748
92727
93084
548834
1741725
4210818
9800817
9926315
24678050
24678051
```

		
## 线性同余方程组和中国剩余定理

- 线性同余方程组的定义。
- 编程求解给定的线性同余方程组（各模数两两互质），要求给出至少十个解。运行效果如下：

```console
$ ./crt
<3>
<3 2>
<5 3>
<7 2>
23
128
233
338
443
548
653
758
863
968
```

		
## 裴蜀定理和扩展欧几里得算法

- 买菜的故事。
- 编程判定形如 `ax + by = d` 的不定方程（其中，`a, b, d` 为整数，均不等于 `0`）是否有整数解，若有解，给出 10 个解。运行效果如下：

```console
$ ./bezout
<23 7 1>            # 三个非零整数（32 位有符号整数），分别是 ax + by = d 不定方程中的 a, b, d
-3 10
4 -13
11 -36
18 -59
25 -82
32 -105
39 -128
46 -151
53 -174
60 -197
$ ./bezout
<12 15 4>
NO SOLUTION
```

	
裴蜀（Bezout）定理

- 若 `$ a, b $` 是不全为零的整数，且 `$ gcd(a, b) = d $`，则 `$ ax + by = m $` 有正整数解，当且仅当 `$ m $` 是 `$ d $` 的整数倍；若有解，则有无穷多个解。
- 设其中一个解是 `$ x_0, y_0 $`，且，`$ m_0 = \frac{m}{d} $`，则上述方程的解集为：

`$$
\left \{ \left( m_0 x_0 + \frac{kb}{d}, m_0 y_0 - \frac{ka}{d} \right) \vert k \in \mathbb{Z} \right \}
$$`

	
- 利用扩展欧几里得算法，在求最大公约数的同时求出 `$ x_0, y_0 $`：

```cpp
intmax_t ex_gcd(intmax_t a, intmax_t b, intmax_t& x, intmax_t& y)
{
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }

    intmax_t gcd = ex_gcd(b, a % b, x, y);
    intmax_t temp = x;
    x = y;
    y = temp - a / b * y;
    return gcd;
}
```

		
## 进制转换

- 进制转换有两种形式：
  1. 解析特定进制表达的字符串并转换为对应的整数。
  1. 将一个整数转换成指定进制表达的字符串。
- 进制转换的数学原理

	
- 编程将将用户输入的一个特定进制表达的数用十进制展示出来。运行效果如下：

```console
$ ./convert-string-in-specific-base
<56ABC 20>  # 第一个数值指定一个用于表达某个数值的字符串，第二个数字指定该字符串所表达的数值的进制，两者用空格分隔。
852232
```

	
- 编程将用户输入的一个自然数转换为 -36 到 36 的进制展示出来。运行效果如下：

```console
$ ./show-number-in-different-bases
<1900>
(11101101100)2
(1100010111100)-2
(2121101)3
(120102101)-3
(131230)4
(1203310)-4
(30100)5
(30100)-5
(12444)6
(24524)-6
(5353)7
(12423)-7
(3554)8
(15634)-8
(2541)9
(17651)-9
(1900)10
(19900)-10
(1478)11
(1A548)-11
(1124)12
(1B2A4)-12
(B32)13
(CA2)-13
(99A)14
(A5A)-14
(86A)15
(99A)-15
(76C)16
(8AC)-16
(69D)17
(78D)-17
(5FA)18
(63A)-18
(550)19
(6E0)-19
(4F0)20
(550)-20
(46A)21
(5FA)-21
(3K8)22
(428)-22
(3DE)23
(4AE)-23
(374)24
(4H4)-24
(310)25
(4O0)-25
(2L2)26
(352)-26
(2GA)27
(3BA)-27
(2BO)28
(3HO)-28
(27F)29
(3MF)-29
(23A)30
(3RA)-30
(1U9)31
(219)-31
(1RC)32
(25C)-32
(1OJ)33
(29J)-33
(1LU)34
(2DU)-34
(1JA)35
(2GA)-35
(1GS)36
(2KS)-36
```

		
## 高精度算术：求阶乘之和

- 给定自然数 `$ n \ (0 \le n \le 2^{32}-1) $`，给出 `$ 0! + 1! + 2! + \cdots + n! $` 的结果（阶乘之和）。运行效果如下：

```console
$ ./summary-of-factorials
<100>
94269001683709979260859834124473539872070722613982672442938359305624678223479506023400294093599136466986609124347432647622826870038220556442336528920420940314
```

	
### 高精度算术（字符串实现）：求和

```cpp
void nap_add_to(string &r, const string &a)
{
    size_t len_r = r.length();
    size_t len_a = a.length();
    size_t len_max = (len_r > len_a) ? len_r : len_a;

    int carry = 0;
    for (size_t i = 0; i < len_max; i++) {
        int value_r = ((i < len_r) ? r[len_r - i - 1] : '0') - '0';
        int value_a = ((i < len_a) ? a[len_a - i - 1] : '0') - '0';

        value_r += value_a + carry;
        if (value_r >= 10) {
            carry = 1;
            value_r -= 10;
        }
        else
            carry = 0;

        if (i >= len_r)
            r.insert(0, 1, '0' + value_r);
        else
            r[len_r - i - 1] = '0' + value_r;
    }

    if (carry > 0) {
        r.insert(0, 1, '1');
    }
}
```

		
## 高精度算术：求小于平方根的最大整数

- 给定一个任意长度的自然数，求小于等于其平方根的最大整数。运行效果如下：

```console
$ ./maximum-le-sqrt
<100>
10
$ ./maximum-le-sqrt
<1234567890>
35136
$ ./maximum-le-sqrt
<123456789098765432101234567890123456789>
11111111064999999904
```

	
### 二分搜索的典型实现

```cpp
template <class T>
const T* binary_search(const T* arr, const T& needle, size_t start, size_t end)
{
    const T* found = nullptr;

    size_t mid;
    while (start <= end) {
        mid = start + ((end - start) >> 1);
        if (arr[mid] < needle)
            start = mid + 1;
        else if (arr[mid] > needle)
            end = mid - 1;
        else {
            found = arr + mid;
            break;
        }
    }

    return found;
}
```

		
## 高精度算术：求商及余数

- 给定两个任意长度的正整数，计算相除的结果（整数商及余数）。运行效果如下：

```console
$ ./division-with-remainder
<11 13>
0 11
$ ./division-with-remainder
<78260869565217391304347826086956521 4347826086956521739130434782608695>
18 11
$ ./division-with-remainder
<100 0>
NO SOLUTION
```

		
## 整数分解

给定任意正整数 `n`，列出用于计算 `D(n)` 和 `O(n)` 的所有可能形式。运行效果如下：

```console
$ ./dn-on
<3>
3
2 1
---
3
1 1 1
```

		
## 整数的因子分解

- 整数的因子分解在计算机技术中有至关重要的意义。
- 给定任意大于 1 的正整数，给出其所有质因子（重复的质因子只保留一个）。运行效果如下：

```console
$ ./prime-factors
<12>
2, 3.
$ ./prime-factors
<11>
11.
```

	
### 朴素算法

- 类似质数判定的试除法，在 `$ \left[ 2, \sqrt{n} \right] $` 中遍历。

```cpp
using namespace std;
using factor_v = vector<uintmax_t>;

factor_v prime_factors(uintmax_t n)
{
    factor_v factors;

    for (uintmax_t i = 2; i <= n; i++) {
        if (n % i == 0) {
            do {
                n = n / i;
            } while (n % i == 0);

            factors.push_back(i);
        }
    }

    return factors;
}
```

	
### Pollard Rho 算法

- 

		
## 斐波那契数列

- 斐波那契数列（Fibonacci sequence）的神奇性质。
- 挑战：性能和溢出
- 实现方法：递归、迭代、倍增法、通项公式
- 倍增法利用如下性质：
- 计算指定序号（第一个的序号为 0）的斐波那契数值。运行效果如下：

```console
$ ./nth-fibonacci-number
<50>
12586269025

$ ./nth-fibonacci-number
<100>
OVERFLOWED
```

	
### 倍增法

- 倍增法利用如下斐波那契数列的性质：

`$$
\begin{align}
  F_{2k} & = F_k(2F_{k+1} - F{k}) \\
  F_{2k+1} & = F^2_k + F^2_k
\end{align}

$$`

	
### 通项公式

- 通项公式（Binet's Formula）

`$$
F_{n} = \frac{\left( \frac{1 + \sqrt{5}}{2} \right)^n - \left( \frac{1 - \sqrt{5}}{2} \right)^n}{\sqrt{5}}
$$`

- 或，

`$$
F_{n} = \left[ \frac{\left( \frac{1 + \sqrt{5}}{2} \right)^n}{\sqrt{5}} \right]
$$`

		
## 有理数的最简分数表达

- 任意有理数（无限循环小数）都可以表达成两个整数的商，若这个两个整数互质，则构成一个最简分数表达。
- 给定一个十进制小数表达的有理数 `$ q $`（`$ q \ge 0 $`），给出其最简分数表达。运行效果如下：

```console
$ ./rational-number-to-fraction
<0.3 1>        # 第二个数字表示循环位
1/3

$ ./rational-number-to-fraction
<48.8260869565217391304347 22>
1123/23
```

