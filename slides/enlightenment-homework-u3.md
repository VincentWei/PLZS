# 信息学启蒙作业讲解<br/>`第三单元 数论基础`

		
## 第一讲 从自然数到整数

	
1) 完成如下计算，如遇代数式，则 `$ a $` 取 `$ 11 $`，`$ b $` 取 `$ -33 $`：

`$$
\begin{align}
    0 - 88 &= -88               \\
    0 + -88 &= -88              \\
    -88 \times b &= 2904        \\
    88 \times -3 &=  -264       \\
    0 - a \times 3 &= -33       \\
    123 - 256 &= -133           \\
    \mid -256 \mid &=  256      \\
    \mid 256 \mid &=   256      \\
    100 + 120 \div (12 - \mid 17 - 26 \mid) \times 6 &= 340 \\
    (a - b) \div 11 &= 4        \\
\end{align}
$$`

	
2) 展开并计算如下代数和式，体验代数的简洁之美：`$ \displaystyle{ \sum_{n=0}^{5}(-1)^n n } $`。

`$$
\large{
\begin{align}
    &\displaystyle{ \sum_{n=0}^{5}(-1)^n n } \\
    &= (-1)^0 \times 0 + (-1)^1 \times 1 + (-1)^2 \times 2 + (-1)^3 \times 3 + (-1)^4 \times 4 + (-1)^5 \times 5 \\
    &= 0 - 1 + 2 - 3 + 4 - 5 \\
    &= -3
\end{align}
}
$$`

	
3) 增强加法实现的乘法考鼎码算法，使之支持负数作为被乘数或乘数。

```mathematica
算始 乘法 (n, m)
    若始 (m < 0)
        m := -m
        n := -n
    若终

    r := 0
    当始 (m != 0)
        r := r + n
        m := m - 1
    当终

    输出 r
算终
```

		
## 第二讲 整数的性质

	
1) 当 `$ n $` 分别取 `$ -4 $`、`$ -3 $`、`$ -2 $`、`$ -1 $`、`$ 0 $`、`$ 5 $` 时，计算对应代数式的值：

`$$
\begin{align}
    &n      &=  &-4 \quad   &-3 \quad   &-2 \quad   &-1 \quad   &0 \quad &5 \\
    &2n     &=  &-8 \quad   &-6 \quad   &-4 \quad   &-2 \quad   &0 \quad &10 \\
    &2n + 1 &=  &-7 \quad   &-5 \quad   &-3 \quad   &-1 \quad   &1 \quad &11 \\
    &n^2    &=  &16 \quad   &9 \quad    &4 \quad    &1 \quad    &0 \quad &25 \\
    &n^3    &=  &-64 \quad  &-27 \quad  &-8 \quad   &-1 \quad   &0 \quad &125 \\
\end{align}
$$`

	
2) 写出 `$ 30 $` 以内的所有质数。

`$$
\large{
    2,\ 3,\ 5,\ 7,\ 11,\ 13,\ 17,\ 19,\ 23,\ 29
}
$$`

	
3) 编写考鼎码算法，计算从 `$ 1 $` 开始的 `$ n $` 个奇数之和。

```mathematica
算始 奇数之和 (n)

    r := 0
    i := 0
    当始 (i < n)
        r := r + (i * 2 + 1)
        i := i + 1
    当终

    输出 r
算终
```

	
4) 编写考鼎码算法，判定一个给定的整数是否为一个完全立方数。

```mathematica
算始 是否为完全立方数 (n)
    若始 (n < 0)
        n := -n
    若终

    i := 1
    当始 (i <= n)
        若始 (i * i * i == n)
            输出 真
            终止    # 此时算法必须提前终止
        若终

        i := i + 1  # 别忘了递增，否则会死循环
    当终

    输出 假
算终
```

	
优化版：

```mathematica
算始 是否为完全立方数 (n)

    若始 (n < 0)
        n := -n
    若终

    i := 1
    当始 (i <= n)
        i3 := i * i * i
        若始 (i3 > n)
            跳出
        若又 (i3 == n)
            输出 真
            终止    # 此时算法必须提前终止
        若终

        i := i + 1  # 别忘了递增，否则会死循环
    当终

    输出 假
算终
```
	
简洁版：

```mathematica
算始 是否为完全立方数 (n)

    若始 (n < 0)
        n := -n
    若终

    i := 1
    当始 (真)
        i3 := i * i * i
        若始 (i3 > n)
            跳出
        若又 (i3 == n)
            输出 真
            终止    # 此时算法必须提前终止
        若终

        i := i + 1  # 别忘了递增，否则会死循环
    当终

    输出 假
算终
```

		
## 第三讲 完美数

	
1) 列出下列各数的真因子（第一行为示例解答）：

`$$
\begin{align}
    4  &:  1, 2                     \\
    2  &:  1                        \\
    12 &:  1, 2, 3, 4, 6            \\
    25 &:  1, 5                     \\
    77 &:  1, 7, 11                 \\
\end{align}
$$`

	
2) 编写考鼎码算法，判定给定的正整数是不是完美数。

<div class="long-code">

```mathematica
# n 必须为正整数
算始 是否为完美数 (n)
    # 获取 n 的真因子序列
    s := []
    i := 1
    当始 (i < n)
        若始 (n % i == 0)
            s := s + [i]
        若终
        i := i + 1
    当终

    # 计算真因子之和
    sum := 0
    i := 0
    当始 (s[i] != 未定义)
        sum := sum + s[i]
        i := i + 1
    当终

    # 判断是否为完美数
    若始 (sum == n)
        输出 真
    若否
        输出 假
    若终
算终
```

</div>

	
3) 如果某个正整数 `$ a $` 的真因子之和为 `$ b $`，而 `$ b $` 的真因子之和为 `$ a $`，则称 `$ a, b $` 为一对亲和数。古希腊的毕达哥拉斯于两千年前发现了第一对亲和数：`$ 220, 284 $`。请编写考鼎码算法，判定给定的两个正整数是不是亲和数。

```mathematica
# a, b 必须为正整数
算始 是否为亲和数 (a, b)
    # 获取 a 的真因子序列
    s := []
    i := 1
    当始 (i < a)
        若始 (a % i == 0)
            s := s + [i]
        若终
        i := i + 1
    当终

    # 计算 a 的真因子之和
    sum := 0
    i := 0
    当始 (s[i] != 未定义)
        sum := sum + s[i]
        i := i + 1
    当终

    # 判断 a 的真因子之和是否等于 b
    若始 (sum != b)
        输出 假
        终止        # 算法这时可直接终止
    若终

    # 获取 b 的真因子序列
    s := []
    i := 1
    当始 (i < b)
        若始 (b % i == 0)
            s := s + [i]
        若终
        i := i + 1
    当终

    # 计算 b 的真因子之和
    sum := 0
    i := 0
    当始 (s[i] != 未定义)
        sum := sum + s[i]
        i := i + 1
    当终

    # 判断 b 的真因子之和是否等于 a
    若始 (sum == a)
        输出 真
    若否
        输出 假
    若终
算终
```

		
## 第四讲 自恋数

	
1) 求出下列十进制三位数各位的立方和（第一行为示例解答）：

`$$
\begin{align}
    123  &:  1^3 + 2^3 + 3^3 = 36 \\
    234  &:  2^3 + 3^3 + 4^3  = 99 \\
    205  &:  2^3 + 0^3 + 5^3  = 133 \\
\end{align}
$$`

	
2) 写出满足自恋数条件的十进制数对应的代数等式。

`$$
\large{
    (d_{n-1} \cdots d_1d_0)_{10} = d_{n-1}^n + \cdots + d_1^n + d_0^n
}
$$`

或，

`$$
\large{
    (d_n \cdots d_2d_1)_{10} = d_n^n + \cdots + d_2^n + d_1^n
}
$$`

	
3) 小明希望从 `$ 1 $` 开始的 `$ n $` 个奇数的连乘积式之结果随奇数的数量而发生正负号的变化：偶数个奇数的积式其结果为正值，奇数个奇数的积式其结果为负值。请写出对应的代数式。

`$$
\large{
    \prod_{k=1}^n -(2k-1)
}
$$`

或，

`$$
\large{
    (-1)^n \prod_{k=1}^n (2k-1)
}
$$`

	
4) 编写考鼎码算法，找出小于等于给定正整数 `$ n $` 的所有自恋数。

```mathematica
算始 列出自恋数 (n)
    k = 1
    当始 (k < n)

        # k 的十进制各位序列
        s := []
        e := 0      # 序列的长度也就是一共有多少十进制位数
        x := k      # 使用 x 计算十进制各位；k 要保持不变，
                    # 因为下面还要用
        当始 (x != 0)
            r := x % 10
            s := [r] + s
            x := x // b
            e := e + 1
        当终

        # 计算十进制各位的 e 次方之和
        sum := 0
        i := 0
        当始 (i < e)
            # 计算当前位的 e 次方
            power := 1
            j := 0
            当始 (j < e)
                power := power * s[i]
                j := j + 1
            当终

            # 将 power 加到 sum 中
            sum := sum + power
            i := i + 1
        当终

        # 判断是否为自恋数
        若始 (sum == k)
            输出 k
        若终

        k := k + 1
    当终
算终
```

		
## 第五讲 质数的判定

	
1) 挑选出 `$ 1,\ 2,\ 7,\ 8,\ 31,\ 87,\ 91,\ 100,\ 201,\ 992 $` 当中的质数。

`$$
\large{
    2,\ 7,\ 31
}
$$`

	
2) 从 `$ 500! + 2 $` 开始一路取到 `$ 500! + 500 $`，则将得到 `$ 499 $` 个连续的整数，且这些整数均有大于 `$ 2 $` 的因子。请据此证明：两个相邻质数之间的缺口可以任意长。

- 证明：
   1. 给定任意大于 `$ 2 $` 的正整数 `$ n $`。
   1. 从 `$ (n-1)! + 2 $` 开始一路取到 `$ (n-1)! + (n-1) $`，则将得到 `$ n-2 $` 个连续的整数，且这些整数均有大于 `$ 2 $` 的因子，所以全部为合数。
   1. 设小于 `$ (n-1)! + 2 $` 的最大的质数是 `$ p_1 $`，大于 `$ (n-1)! + (n-1) $` 的最小的质数是 `$ p_2 $`，则一定有 `$ p_2 - p_1 > n - 2 $`。
   1. 又因为 `$ p_1,\ p_2 $` 之间全是合数，所以这两个质数为相邻质数。
   1. 因为这里的 `$ n $` 可以取任意大的值，故而得出结论：两个相邻质数之间的缺口可以任意长。
   1. 证毕！

	
3) 优化本节给出的质数判定算法。

```mathematica
# 这个算法假设传入的参数 n 是正整数
算始 是否为质数 (n)
    若始 (n < 2)
        返回 假
    若终

    若始 (n == 2)
        返回 真
    若终

    i := 2
    # 只要 i 的平方大于 n 就没必要继续判断了
    当始 (i * i <= n)
        若始 (n % i == 0)
            返回 假
        若终
        i := i + 1
    当终

    返回 真
算终
```

		
## 第六讲 算术基本定理

	
1) 分解如下整数，将其写成质因子的幂相乘的形式（第一行为示例解答）：

`$$
\begin{align}
    100 &= 2^2 \times 5^2       \\
    88  &= 2^3 \times 11        \\
    127 &= 127                  \\
    256 &= 2^8                  \\
    565 &= 5 \times 113         \\
    999 &= 3^3 \times 37        \\
\end{align}
$$`

	
2) 设定一个已知质数构成的序列，初始时，该序列中只有 `2` 一个元素。然后从 `3` 开始依次检测每个整数，用已知质数序列中的每个质数去除这个整数。如果某个已知质数是这个整数的因子，则该整数为一个合数，否则该整数为下一个新发现的质数，并将其加入到已知质数的序列当中。如此，我们可以生成一个包含从小到大排列的所有质数的序列。请按此方法编写考鼎码算法，生成小于等于给定正整数 `n` 的所有质数序列。请思考上述算法的至少一个优化点。

	
- 朴素版本

<div class="long-code">

```mathematica
算始 生成质数序列 (n)
    若始 (n < 2)
        返回 []
    若又 (n == 2)
        返回 [2]
    若终

    primes := [2]
    k := 3
    当始 (k <= n)

        i := 0
        flag := 真      # 这个标志先假定 k 为质数
        当始 (primes[i] != 未定义)
            若始 (k % primes[i] == 0)
                flag := 假  # k 是个合数，设置 flag 为假
                跳出        # 不用继续判断，跳出循环

                i := i + 1
            若终
        当终

        # 若 flag 未被修改为 假，
        # 则表明没有已知质数可以整除 k，
        # 也就是说 k 是质数
        若始 (flag == 真)
            primes := primes + [k]
        若终

        k := k + 1
    当终

    返回 primes
算终
```

</div>

	
- 优化版本

<div class="long-code">

```mathematica
算始 生成质数序列 (n)
    若始 (n < 2)
        返回 []
    若又 (n == 2)
        返回 [2]
    若终

    primes := [2]
    k := 3
    当始 (k <= n)

        i := 0
        flag := 真      # 这个标志先假定 k 为质数
        当始 (primes[i] != 未定义)
            若始 (k % primes[i] == 0)
                flag := 假  # k 是个合数，设置 flag 为假
                跳出        # 不用继续判断，跳出循环

                i := i + 1
            若终
        当终

        # 若 flag 未被修改为 假，
        # 则表明没有已知质数可以整除 k，
        # 也就是说 k 是质数
        若始 (flag == 真)
            primes := primes + [k]
        若终

        # k 从 3 开始，只需要检测奇数
        k := k + 2
    当终

    返回 primes
算终
```

</div>

	
3) 尝试证明：任意合数至少有一个质因数。

- 证明：
   1) 根据合数的定义，给定的任意合数 `$ n $` 可以分解为两个整数之乘积，且这两个整数均不为 `$ 1 $` 和 `$ n $`。也就是说有：`$ n = a \times b,\ (1 < a < n,\ 1 < b < n) $`。
   2) `$ a $` 和 `$ b $` 有三种情况：第一，全是质数；第二，有一个是质数另一个是合数；第三，全是合数。若是前两种情况，则满足命题所述。
   3) 对第三种情况，取其中一个合数，设其为 `$ n_1 $`，然后继续分解 `$ n_1 $` 并判断其两个因子。
   4) 重复以上过程 `$ i $` 次，并假设每次得到的两个因子均为合数（步骤 2 中的第三种情况），则必然有 `$ 1 < n_{i + 1} < n_i < \cdots < n_1 < n $`。
   5) 另外注意到每次分解得到的下个因子一定满足 `$ n_{i+1} \le (n_{i} \div 2) \ge  $`，故而可判断此步骤将最多在 `$ \log_2^n $` 步后结束。
   6) 假定以上过程在第 `$ m $` 次时停止，则最后分解得到的 `$ n_{m+1} $` 不能被除 `$ 1 $` 和 `$ n_{m+1} $` 整除，因此是一个质数。于是得证。

		
## 第七讲 整数的质因子分解

	
1) 写出质因子分解算法朴素版的考鼎码；该考鼎码分解一个大于 `$ 1 $` 的正整数 `$ n $`，返回一个序列，其中包含该正整数的所有的质因子。注意：如果是该正整数是一个质数，则结果序列中应仅包含自己。

<div class="long-code">

```mathematica
算始 质因子分解 (n)
    若始 (n < 2)
        返回 []
    若又 (n < 4)
        返回 [n]
    若终

    # factors 用来保存找到的质因子，初始化为空序列
    factors := []

    k := 2
    当始 (k <= n)

        若始 (n % k == 0)
            # 以下代码段判断 k 是否为质数

            # 这个标志先假定 k 为质数
            flag := 真
            i := 2
            当始 (i * i < k)
                若始 (k % i == 0)
                    # k 是个合数，设置 flag 为假
                    flag := 假
                    跳出
                若终
                i := i + 1
            当终

            # 若 flag 未被修改为 假，说明 k 是质数
            # 加入到 factors 序列
            若始 (flag == 真)
                factors := factors + [k]
            若终
        若终

        k := k + 1
    当终

    返回 factors
算终
```

</div>

	
2) 写出质因子分解算法优化版的考鼎码；要求同上。

<div class="long-code">

```mathematica
算始 质因子分解 (n)
    若始 (n < 2)
        返回 []
    若又 (n < 4)
        返回 [n]
    若终

    # factors 用来保存找到的质因子，初始化为空序列
    factors := []

    k := 2
    当始 (k <= n)

        若始 (n % k == 0)

            # 将 n 中所有的 k 除尽
            # 比如 n 为 100 时，以下循环会让 n 变成 25
            当始 (n % k == 0)
                n := n // k
            当终

            factors := factors + [k]
        若终

        k := k + 1
    当终

    返回 factors
算终
```

</div>

	
3) 试着证明：若一个正整数 `$ a $` 的平方为偶数，则 `$ a $` 一定是偶数。

- 证明：
   1) 一个数要么是奇数要么是偶数，而一个奇数的平方始终为奇数，一个偶数的平方始终为偶数。
   2) 故，若一个正整数 `$ a $` 的平方为偶数，则 `$ a $` 一定是偶数。

		
## 第八讲 欧几里得算法

	
1) 利用短除法手工求 `30` 和 `22` 的最大公因子。

`$$
\large{
    \gcd(30, 22) = 2
}
$$`<!-- .element: class="fragment fade-in" -->

	
2) 利用欧几里得算法手工求 `337` 和 `21` 的最大公因子。

`$$
\large{
    \gcd(337, 21) = \gcd(21, 1) = 1
}
$$`<!-- .element: class="fragment fade-in" -->

	
3) 若两个数的最大公因子为 `$ 1 $`，则称这两个数为互质。请从 `$ 1,\ 2,\ 3,\ 9,\ 25,\ 31,\ 91 $` 中挑选出所有互质的数对（如 `$ (2,\ 3) $`）。

`$$
\large{
\begin{align}
    (1, 2); (1, 3); (1, 9); (1, 25); (1, 31); (1, 91); \\
    (2, 3); (2, 9); (2, 25); (2, 31); (2, 91); \\
    (3, 25); (3, 31); (3, 91); \\
    (9, 25); (9, 31); (9, 91); \\
    (25, 31); (25, 91); \\
    (31, 91);
\end{align}
}
$$`<!-- .element: class="fragment fade-in" -->

	
4) 使用本讲给出的欧几里得算法，当给定的初始值 `a, b` 取下列各值时，写出算法结束时各变量的值以及执行结果（注：使用表格）。  
      a) `a=22, b=11`<br/>
      b) `a=125, b=20`

<div class="narrow-table">

| 初始 `a` |  初始 `b` |  结束 `tmp` | 结束 `a` | 结束 `b` | 结果  |
| ---      | ---       | ---         |  ---     |  ---     | ---   |
| `22`     | `11`      | `22`        | `11`     | `0`      | `11`  |
| `125`    | `20`      | `20`        | `5`      | `0`      | `5`   |

</div>

	
5) 为防止在取模过程中出现除数为零的情形，需要调整本讲给出的欧几里得算法，请尝试添加代码使之可以避免出现除数为零的情况。

```mathematica
算始 最大公因数 (a, b)
    # 处理 a, b 之一等于零的情况
    若始 (a == 0 或 b == 0)
        返回 未定义
    若终

    当始 (b != 0)
        tmp := a
        a := b
        b := tmp % b
    当终

    返回 a
算终
```

	
6) 写出求最小公倍数的考鼎码。

```mathematica
算始 最小公倍数 (a, b)
    # 处理 a, b 之一等于零的情况
    若始 (a == 0 或 b == 0)
        返回 未定义
    若终

    # 先求出 a, b 的积
    prod := a * b

    # 再求最大公约数
    当始 (b != 0)
        tmp := a
        a := b
        b := tmp % b
    当终

    # 最小公倍数便是积 prod 除以最大公约数的结果
    返回 prod // a
算终
```

		
## 第九讲 中国剩余定理

	
1) 我们可以用考鼎码关键词 `且` 将多个逻辑判断表达式连接在一起，表示多个判断同时为 `真` 时整个结果才能为 `真`。比如 `(x >= 3 且 x < 6)` 表示 `x` 取值范围为大于等于 `3` 且小于 `6`；比如 `x` 取值为 `9` 时，对应表达式的值为 `假`。类似地，我们可以关键词 `或` 连接多个逻辑判断表达式，用来表示这些表达式只要有一个为 `真` 则整个结果为 `真`。请使用考鼎码关键词 `且` 调整本节给出的孙子定理朴素解法之考鼎码。

```mathematica
算始 孙子定理朴素解法
    x := 2

    当始 (x < 1000)

        若始 (x % 3 == 2 且 x % 5 == 3 且 x % 7 == 2)
            返回 x
        若终

        x := x + 1
    当终

    # 返回 0 表示未找到
    返回 0
算终
```

	
2) 本讲给出的孙子定理朴素解法有点低效，请尝试优化。

```mathematica
算始 孙子定理朴素解法
    x := 2

    当始 (x < 1000)

        若始 (x % 3 == 2 且 x % 5 == 3 且 x % 7 == 2)
            返回 x
        若终

        # 符合条件的解一定至少以最小的模数（3）递增
        x := x + 3
    当终

    # 返回 0 表示未找到
    返回 0
算终
```

	
3) 满足中国剩余定理所述问题的整数是唯一的吗？如果不唯一且得到一个解，那么满足该定理的其他整数如何求得？请给出其考鼎码。

不唯一，有无穷多个解。

```mathematica
# x 是已知的解，n 是要给出的解的个数
算始 孙子定理问题的其他解 (x, n)

    k := 0
    当始 (k < n)

        # 105 是 3, 5, 7 的最小公倍数
        输出 x + k * 105

        k := k + 1
    当终
算终
```

	
4) 思考如果模数不是固定的 `$ 3,\ 5,\ 7 $`，对应的余数也不是固定的 `$ 2,\ 3,\ 3 $`，甚至可能给出更多的模数和对应的余数，我们需要如何改造考鼎码算法以适应这种情况？

使用序列传入模数和对应的余数。

```mathematica
# m_s 是模数序列；
# r_s 是余数序列；
# n 是模数或余数的数量（n > 1）；
# max 是测试最大值
算始 孙子定理朴素解法灵活版 (m_s, r_s, n, max)

    # 找到最小的余数
    x := r_s[0]
    i : = 1
    当始 (i < n)
        若始 (r_s[i] < x)
            x := r_s[i]
        若终
        i := i + 1
    当终

    # 找到最小的模数作为递增值
    d := m_s[0]
    i : = 1
    当始 (i < n)
        若始 (m_s[i] < d)
            d := m_s[i]
        若终
        i := i + 1
    当终

    当始 (x < max)

        # 该变量用来记录当前 x 满足的同余条件之数量
        k := 0

        i := 0
        当始 (i < n)
            若始 (x % m_s[i] == r_s[i])
                k := k + 1  # x 满足当前的同余条件，k 递增
            若终

            i := i + 1
        当终

        # 若 x 满足所有的同余条件，则找到一个解
        若始 (k == n)
            返回 x
        若终

        # 符合条件的解一定至少以最小的模数递增
        x := x + d
    当终

    # 返回 0 表示未找到
    返回 0
算终
```

	
5) 孙子定理提到的 `$ 3,\ 5,\ 7 $` 这样的模数是两两互质的。请思考如果这些模数不满足两两互质的条件，会导致什么样的结果？

可能无解。

		
## 第十讲 幻方

	
1) 已知填充幻方的连续整数的起始值 `$ n $`，写出计算 `$ 3 \times 3 $` 幻方各行、列或对角线之和的考鼎码算法。

```mathematica
# n 是起始整数（n > 0）
算始 三乘三幻方行列和 (n)

    # 计算从 n 开始的 9 个连续整数之和
    sum := n * 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1
    输出 sum // 3
算终
```

或者，

```mathematica
# n 是起始整数（n > 0）
算始 三乘三幻方行列和 (n)

    # 计算从 n 开始的 9 个连续整数之和
    sum := 0
    i := 0
    当始 (i < 9)
        sum := sum + n
        n := n + 1
    当终

    输出 sum // 3
算终
```

	
2) 在以上条件下，写出确定对应幻方中心位置数值的考鼎码算法。

```mathematica
# n 是起始整数（n > 0）
算始 三乘三幻方中心数 (n)

    # 计算从 n 开始的 9 个连续整数之和
    s := n * 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1
    # 计算行列和
    rs := s // 3

    输出 (4 * rs - s) // 3
算终
```

	
3) 在以上条件下，画出当选择两个中心位置之外的数值分别填充左上角和右上角，然后确定其他格子的数值并得出是否可以成功解出幻方的算法流程图。

<div class="wide-code">

```mathematica
# n 是起始整数（n > 0）
算始 填充三乘三幻方 (n)

    # n_s 中保存从 n 开始的九个连续整数
    n_s := [n, n+1, n+2, n+3, n+4, n+5, n+6, n+7, n+8]

    # row1, row2, row3 分别表示第一行、第二行、第三行的格子
    row1 := []
    row2 := []
    row3 := []

    # 计算从 n 开始的 9 个连续整数之和
    s := 0
    i := 0
    当始 (n_s[i] != 未定义)
        s := s + n_s[i]
        i := i + 1
    当终

    # 计算行列及主对角线之和
    rs := s // 3

    # 确定中心位置的数
    c := (4 * rs - s) // 3

    # 将中心位置的数从 n_s 中移除
    n_s[c - n] = 未定义

    # i 表示当前从剩余的数中选来试着填入左上角的数的索引
    i := 0
    当始 (i < 8)

        # 将 c 放入幻方中心，其他清零
        row1[0] := 0; row1[1] := 0; row1[2] := 0
        row2[0] := 0; row2[1] := c; row2[2] := 0
        row3[0] := 0; row3[1] := 0; row3[2] := 0

        # left_ns 表示剩余可选的数构成的序列
        left_ns := n_s

        # 从 left_ns 中选择索引为 i 的数填充到左上角
        row1[0] := left_ns[i]

        # 将这个数从 left_ns 中移除
        left_ns[i] := 未定义

        # 确定右下角的数
        d = rs - c - left_ns[i]

        # 先确定这个数是否是 n 开始的连续 9 个数。
        # 若不是，则继续测试下个 i。
        若始 (d < n 或 d > (n + 8))
            i := i + 1
            继续
        若终

        # 然后确定这个数是否在 left_ns 序列中。
        # 若在，则设置格子并从 left_ns 中移除；
        # 若不在，则继续下一个 i。
        k := 0
        当始 (d > 0 且 left_ns[k] != 未定义)
            若始 (left_ns[k] == d)
                row3[2] := d
                left_ns[k] := 未定义
                d := 0      # 设置 d 为零，用作标志
                跳出
            若终

            k := k + 1
        当终

        # 若 d 不等于 0，则表明 d 不在剩余可选的数当中，继续下个 i
        若始 (d != 0)
            i := i + 1
            继续
        若终

        # 选择 left_ns 中的一个数填入右上角。
        # j 表示当前从剩余的数中选来试着填入右上角的数的索引。
        # 注意，此时剩余的数一共有 6 个。
        j : = 0
        当始 (j < 6)
            # left_ns2 表示在当前这一轮选择中剩余可选的数构成的序列。
            # 为不影响 left_ns 中的内容，需要一个新的序列。
            left_ns2 := left_ns

            row1[2] := left_ns2[j]
            left_ns2[j] := 未定义    # 从序列中移除

            # 确定中上格子中的数
            d := rs - row1[0] - row1[2]

            # 先确定这个数是否是 n 开始的连续 9 个数。
            # 若不是，则继续测试下个 j。
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            # 然后再确定这个数是否在 left_ns2 序列中。
            # 若在，则设置格子并从 left_ns2 中移除；
            # 若不在，则继续测试下一个 j。
            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row1[1] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            # d 不等于 0 表明 d 不在 left_ns2 序列中，继续测试下个 j。
            若始 (d != 0)
                j := j + 1
                继续
            若终

            # 确定中下格子中的数
            d := rs - row1[1] - c

            # 确定合理性，逻辑同上
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row3[1] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            若始 (d != 0)
                j := j + 1
                继续
            若终

            # 确定左下格子中的数
            d := rs - row3[1] - row3[2]

            # 确定合理性，逻辑同上
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row3[0] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            若始 (d != 0)
                j := j + 1
                继续
            若终

            # 确定左中格子中的数
            d := rs - row1[0] - row3[0]

            # 确定合理性，逻辑同上
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row2[0] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            若始 (d != 0)
                j := j + 1
                继续
            若终

            # 确定右中格子中的数
            d := rs - row2[0] - c

            # 确定合理性，逻辑同上
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row2[2] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            若始 (d != 0)
                j := j + 1
                继续
            若终

        当终

        # 检查各格子是否全部填好（没有 0）
        若始 (row1[0] == 0 或 row1[1] == 0 或 row1[2] == 0
                或 row2[0] == 0 或 row2[1] == 0 或 row2[2] == 0
                或 row3[0] == 0 或 row3[1] == 0 或 row3[2] == 0)
            # i 递增
            i := i + 1
        若否
            # 已被全部填满，搞定幻方
            跳出
        若终

    当终

    输出 row1
    输出 row2
    输出 row3
算终
```

</div>

	
- 简洁版本

<div class="wide-code">

```mathematica
# n 是起始整数（n > 0）
算始 填充三乘三幻方 (n)

    # n_s 中保存从 n 开始的九个连续整数
    n_s := [n, n+1, n+2, n+3, n+4, n+5, n+6, n+7, n+8]

    # row1, row2, row3 分别表示第一行、第二行、第三行的格子
    row1 := []
    row2 := []
    row3 := []

    # 计算从 n 开始的 9 个连续整数之和
    s := 0
    i := 0
    当始 (n_s[i] != 未定义)
        s := s + n_s[i]
        i := i + 1
    当终

    # 计算行列及主对角线之和
    rs := s // 3

    # 确定中心位置的数
    c := (4 * rs - s) // 3

    # 将中心位置的数从 n_s 中移除
    n_s[c - n] = 未定义

    # i 表示当前从剩余的数中选来试着填入左上角的数的索引
    i := 0
    当始 (i < 8)

        # 将 c 放入幻方中心，其他清零
        row1[0] := 0; row1[1] := 0; row1[2] := 0
        row2[0] := 0; row2[1] := c; row2[2] := 0
        row3[0] := 0; row3[1] := 0; row3[2] := 0

        # left_ns 表示剩余可选的数构成的序列
        left_ns := n_s

        # 从 left_ns 中选择索引为 i 的数填充到左上角
        row1[0] := left_ns[i]

        # 将这个数从 left_ns 中移除
        left_ns[i] := 未定义

        # 确定右下角的数
        d = rs - c - left_ns[i]

        # 找到这个数在 left_ns 序列中的位置，
        # 设置格子并从 left_ns 中移除。
        # 注意：这个数一定在 left_ns 序列中。

        k := 0
        当始 (left_ns[k] != 未定义)
            若始 (left_ns[k] == d)
                row3[2] := d
                left_ns[k] := 未定义
                跳出
            若终

            k := k + 1
        当终

        # 选择 left_ns 中的一个数填入右上角。
        # j 表示当前从剩余的数中选来试着填入右上角的数的索引。
        # 注意，此时剩余的数一共有 6 个。
        j : = 0
        当始 (j < 6)
            # left_ns2 表示在当前这一轮选择中剩余可选的数构成的序列。
            # 为不影响 left_ns 中的内容，需要一个新的序列。
            left_ns2 := left_ns

            row1[2] := left_ns2[j]
            left_ns2[j] := 未定义    # 从序列中移除

            # 确定中上格子中的数
            d := rs - row1[0] - row1[2]

            # 先确定这个数是否是 n 开始的连续 9 个数。
            # 若不是，则继续测试下个 j。
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            # 然后再确定这个数是否在 left_ns2 序列中。
            # 若在，则设置格子并从 left_ns2 中移除；
            # 若不在，则继续测试下一个 j。
            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row1[1] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            # d 不等于 0 表明 d 不在 left_ns2 序列中，继续测试下个 j。
            若始 (d != 0)
                j := j + 1
                继续
            若终

            # 确定中下格子中的数
            d := rs - row1[1] - c

            # 确定合理性，逻辑同上；将来写成函数。
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row3[1] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            若始 (d != 0)
                j := j + 1
                继续
            若终

            # 确定左下格子中的数
            d := rs - row3[1] - row3[2]

            # 确定合理性，逻辑同上
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row3[0] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            若始 (d != 0)
                j := j + 1
                继续
            若终

            # 确定左中格子中的数
            d := rs - row1[0] - row3[0]

            # 确定合理性，逻辑同上
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row2[0] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            若始 (d != 0)
                j := j + 1
                继续
            若终

            # 确定右中格子中的数
            d := rs - row2[0] - c

            # 确定合理性，逻辑同上
            若始 (d < n 或 d > (n + 8))
                j := j + 1
                继续
            若终

            k := 0
            当始 (left_ns2[k] != 未定义)
                若始 (left_ns2[k] == d)
                    row2[2] := d
                    left_ns2[k] := 未定义
                    d := 0
                    跳出
                若终

                k := k + 1
            当终

            若始 (d != 0)
                j := j + 1
                继续
            若终

        当终

        # 检查各格子是否全部填好（没有 0）
        若始 (row1[0] == 0 或 row1[1] == 0 或 row1[2] == 0
                或 row2[0] == 0 或 row2[1] == 0 或 row2[2] == 0
                或 row3[0] == 0 或 row3[1] == 0 或 row3[2] == 0)
            # i 递增
            i := i + 1
        若否
            # 已被全部填满，搞定幻方
            跳出
        若终

    当终

    输出 row1
    输出 row2
    输出 row3
算终
```

</div>
