# 中期综合练习

1. 三种算术运算表达式
1. 将中缀表达式解析为求值二叉树
1. 综合练习

		
## 算术运算表达式

`Arithmetic operation expression`

	
### 三种算术运算表达式

- 前缀表达式（prefix expression）：运算符（operator）位于操作数（operand）之前（波兰式）
   - 简单形式：`+ 3 5`
   - 复杂形式：`+ 3 * 5 8 `
- 中缀表达式（infix expression）：运算符位于操作数之间
   - 简单形式：`3 + 5`
   - 复杂形式：`3 + 5 * 8`
- 后缀表达式（postfix expression）：运算符位于操作数之后（逆波兰式）
   - 简单形式：`3 5 +`
   - 复杂形式：`5 8 * 3 +`
- 以上复杂形式的表达式求值（evalute）过程，本质上相当于函数调用：`add(3, mul(5, 8))`。
- 前缀表达式和后缀表达式的解析和求值，只需要栈即可完成。
- 中缀表达式可转换为前缀表达式或后缀表达式再行求值；亦可解析为求值二叉树再后序遍历求值。

	
#### 前缀表达式的求值

- 算法描述：
  1. 创建一个空的操作数栈 `operands`。
  1. 从右至左扫描表达式。
  1. 若遇到数值，则将数值压入 `operands`；若遇到运算符，则从 `operands` 弹出两个数值，用当前运算符对它们做相应的计算（`先弹出的数值作为运算符左值，后弹出的数值作为运算符右值`），然后将结果压入 `operands`。
  1. 重复上述过程直到表达式全部处理完成；`operands` 栈顶的数值即为该表达式的求值结果。
- 例如：`- × + 3 4 5 6`
  1. 从右至左扫描，依次将 `6`、`5`、`4`、`3` 压入 `operands`。
  1. 其后是 `+` 运算符，从 `operands` 中依次弹出 `3` 和 `4`，计算 `3 + 4`，得 `7`，再将 `7` 压入 `operands`。
  1. 其后是 `×` 运算符，从 `operands` 中依次弹出 `7` 和 `5`，计算 `7 × 5`，得 `35`，将 `35` 压入 `operands`。
  1. 其后是 `-` 运算符，从 `operands` 中依次弹出 `35` 和 `6`，计算 `35 - 6`，得 `29`，将 `29` 压入 `operands`。
  1. 表达式扫描完成，取出栈顶数值 `29`，得出表达式的求值结果为 `29`。

	
#### 后缀表达式的求值

- 算法描述：
  1. 创建一个空的操作数栈 `operands`。
  1. 从左到右扫描表达式。
  1. 若遇到数值，则将数值压入`operands`；若遇到运算符，则从 `operands` 弹出两个数值，用当前运算符对它们做相应的计算（`先弹出的数值作为运算符右值，后弹出的数值作为运算符左值`），然后将结果压入`operands`。
  1. 重复上述过程直到表达式全部处理完成；`operands` 栈顶数值即为该表达式的求值结果。
- 例如：`3 4 + 5 × 6 -`
  1. 将数值 `3`、`4` 压入栈。
  1. 其后是 `+` 运算符，从 `operands` 中依次弹出 `3` 和 `4`，计算 `4 + 3`，得 `7`，再将 `7` 压入 `operands`。
  1. 其后是数值 `5`，压入 `operands`。
  1. 其后是 `×` 运算符，从 `operands` 中依次弹出 `5` 和 `7`，计算 `7 × 5`，得 `35`，将 `35` 压入 `operands`。
  1. 其后是数值 `6`，压入 `operands`。
  1. 其后是 `-` 运算符，从 `operands` 中依次弹出 `6` 和 `35`，计算 `35 - 6`，得 `29`，将 `29` 压入 `operands`。
  1. 表达式扫描完成，取出栈顶数值 `29`，得出表达式的求值结果为 `29`。

	
#### 中缀表达式转换为前缀表达式

- 算法描述：
  1. 初始化两个栈：运算符栈 `operators` 和结果的栈 `result`。
  1. 从右至左扫描中缀表达式。
  1. 遇到操作数时，将其压入 `result`。
  1. 遇到运算符时，比较其与 `operators` 栈顶运算符的优先级。
     1. 如果 `operators` 为空，或栈顶运算符为右括号 `)`，则直接将此运算符入栈；
     1. 否则，若该运算符的优先级比栈顶运算符`高或相等`，将该运算符压入 `operators`；
     1. 否则，将 `operators` 栈顶的运算符弹出并压入到 `result` 中，并转到步骤 4.1。
  1. 遇到括号时，
     1. 如果是右括号 `)`，则直接压入 `operators`。
     1. 如果是左括号 `(`，则依次弹出 `operators` 栈顶的运算符，并压入 `result`，直到遇到右括号为止，此时将这一对括号丢弃。
  1. 重复步骤2，直到表达式的最左边。
  1. 将 `operators` 中剩余的运算符依次弹出并压入 `result`。
  1. 依次弹出 `result` 中的元素并输出，结果即为中缀表达式对应的前缀表达式。

	
- 举例：将中缀表达式 `a+((b+c)×d)-e` 转换为前缀表达式

| 词元  | `result`                  | `operators`       | 说明                                          |
| ---   | ---                       | ---               | ---                                           |
| e     | e                         | EMPTY             | 数值，压入 `results` 栈                       |
| -     | e                         | -                 | 运算符，`operators` 为空，直接入栈            |
| )     | e                         | ), -              | 右括号，压入 `operators` 栈                   |
| d     | d, e                      | ), -              | 数值，压入 `results` 栈                       |
| ×     | d, e                      | ×, ), -           | `operators` 栈顶是右括号，直接入栈            |
| )     | d, e                      | ), ×, ), -        | 右括号，压入 `operators` 栈                   |
| c     | c, d, e                   | ), ×, ), -        | 数值，压入 `results` 栈                       |
| +     | c, d, e                   | +, ), ×, ), -     | `operators` 栈顶是右括号，直接入栈            |
| b     | b, c, d, e                | ), ×, ), -        | 数值，压入 `results` 栈                       |
| (     | + b, c, d, e              | ×, ), -           | 左括号，弹出运算符直至遇到右括号              |
| (     | ×, + b, c, d, e           | -                 | 左括号，从`operators`弹出运算符并压入`result`直至遇到右括号 |
| +     | ×, + b, c, d, e           | +, -              | 优先级与栈顶的 `-` 相同，直接入栈             |
| a     | a, ×, + b, c, d, e        | +, -              | 数值，压入 `results` 栈                       |
| EMPTY | -, +, a, ×, + b, c, d, e  | EMPTY             | 从 `operators` 弹出所有运算符并压入 `result`  |

	
#### 中缀表达式转换为后缀表达式

- 算法描述：
  1. 初始化两个栈：运算符栈 `operators` 和结果栈 `result`。
  1. 从左至右扫描中缀表达式。
  1. 遇到操作数时，将其压入 `result`。
  1. 遇到运算符时，比较其与 `operators` 栈顶运算符的优先级：
     1. 如果 `operators` 为空，或栈顶运算符为左括号 `(`，则直接将此运算符入栈；
     1. 否则，若该运算符的优先级比栈顶运算符`高`，将该运算符压入 `operators`；
     1. 否则，将 `operators` 栈顶的运算符弹出并压入到 `result` 中，并转到步骤 4.1。
  1. 遇到括号时，
     1. 如果是左括号 `(`，则直接压入 `operators`；
     1. 如果是右括号 `)`，则依次弹出 `operators` 栈顶的运算符，并压入 `result`，直到遇到左括号为止，此时将这一对括号丢弃。
  1. 重复步骤2，直到表达式的最右边；
  1. 将 `operators` 中剩余的运算符依次弹出并压入 `result`；
  1. 依次弹出 `result` 中的元素并输出，其结果的`逆序`即为中缀表达式对应的后缀表达式。

	
- 举例：将中缀表达式 `a+((b+c)×d)-e` 转换为后缀表达式

| 词元  | `result`                  | `operators`    | 说明                                          |
| ---   | ---                       | ---               | ---                                           |
| a     | a                         | EMPTY             | 数值，压入 `results` 栈                       |
| +     | a                         | +                 | 运算符，`operators` 为空，直接入栈            |
| (     | a                         | (, +              | 左括号，压入 `operators` 栈                   |
| (     | a                         | (, (, +           | 左括号，压入 `operators` 栈                   |
| b     | b, a                      | (, (, +           | 数值，压入 `results` 栈                       |
| +     | b, a                      | +, (, (, +        | `operators` 栈顶是左括号，直接入栈            |
| c     | c, b, a                   | +, (, (, +        | 数值，压入 `results` 栈                       |
| )     | +, c, b, a                | (, +              | 右括号，弹出运算符压入`result`直至遇到左括号  |
| ×     | +, c, b, a                | ×, (, +           | `operators` 栈顶是左括号，直接入栈            |
| d     | d, + c, b, a              | ×, ), +           | 数值，压入 `results` 栈                       |
| )     | ×, d, + c, b, a           | +                 | 右括号，弹出运算符压入`result`直至遇到左括号  |
| -     | +, ×, d, + c, b, a        | -                 | 优先级与`operators`栈顶的 + 相同，先弹出 + 并压入`result`，再压入 -  |
| e     | e, +, ×, d, + c, b, a     | -                 | 数值，压入 `results` 栈                       |
| NONE  | -, e, +, ×, d, + c, b, a  | EMPTY             | 从 `operators` 弹出所有运算符并压入 `result`  |

		
## 将中缀表达式解析为求值二叉树

- 原理
   1. 单个双目算术运算，可构成一个以操作数为叶子节点，结果为根节点的二叉树。
   1. 有多个运算符参与的混合运算，按优先级或者括号递归处理，然后将这些二叉树铰接在一起；如果某个二叉树的根将作为另一个运算二叉树的操作数，则将其铰接（splice）到那个二叉树上，成为其子节点。此时，括号、前后两个运算符的优先级，将决定如何铰接两个二叉树。
   1. 通过后序遍历求出所有内部节点的值，结束后根节点的值即为表达式的最终求值结果。

	
- 举例
  1. `3 + 5`
  1. `3 + 5 - 6`
  1. `3 + (5 - 6)`
  1. `3 + (5 - 6) × 6`
  1. `[3 + (5 - 6) × 6] ÷ [4 × (3 - 8)]`

		
## 综合练习：算术表达式解析器

`Arithmetic expression parser`

	
编写一个算术表达式解析器（`arithmetic-expression-parser.cpp`）完成中缀表达式的解析和求值。

- 要求支持如下功能：
  1. 读取用户输入的中缀算术表达式；该表达式支持加减乘除四则混合运算，支持负号、括号。
  1. 将中缀表达式转换为前缀表达式进行求值，输出前缀表达式及其求值结果。
  1. 将中缀表达式转换为后缀表达式进行求值，输出后缀表达式及其求值结果。
  1. 将中缀表达式解析为求值二叉树进行求值，按求值二叉树输出其正规中缀表达式（全部使用括号表示运算顺序）及其求值结果。
  1. 若发现表达式有误，输出 `INVALID`。

	
- 运行效果如下：

```console
$ ./arithmetic-expression-parser
<300.5 + 50.6>  // 注意：运算符和操作数之间可能包括任意多的空白字符。
Prefix expression: + 300.5 50.6
    = 351.1
Postfix expression: 50.6 300.5 +
    = 351.1
Normalized infix expression: (300.5 + 50.6)
    = 351.1

$ ./arithmetic-expression-parser
<300.5 + ((5 + 10.6) * 85>
INVALID
```

	
### 实现解析器时要考虑的问题

- 假定表达式使用十进制表示实数或整数，表达式支持 `+`、`-`、`*`、`/` 四则运算以及 `()`，且不含非法字符。注意若数值为整数，还可以支持 `%` 运算。
- 如何处理单目运算符，如负号（`-`）？
  1. 前缀和后缀表达式无法有效识别单目运算符；简单起见，可将负号转为双目运算符，比如 `-5`，对应 `0 - 5`。
  1. 中缀表达式中，可通过上下文判断是否为单目运算符，比如 `-3 + -5`，或者 `(-3) + (-5)`。
- 如何判断非法表达式？
  1. 前缀和后缀表达式的处理中，在执行运算时，若操作数栈中只有一个操作数，则对应表达式为非法。
  1. 将中缀表达式转换为前缀或后缀表达式时，若出现括号不匹配的情形，则表达式为非法。
  1. 将中缀表达式解析为求值二叉树时，若出现括号不匹配的情形，则表达式为非法。
- 如何判断运算符的优先级以及括号的嵌套关系？
  1. 参考中缀表达式转前缀表达式的算法，使用栈来跟踪。

