# 中期综合练习

1. 三种算术运算表达式
1. 将中缀表达式解析为求值二叉树
1. 综合练习
1. 实用技巧及工具

		
## 算术运算表达式

`Arithmetic operation expression`

	
### 三种算术运算表达式

- 前缀表达式（prefix expression）：运算符（operator）位于操作数（operand）之前（波兰式）
   - 简单形式：`+ 3 5`
   - 复杂形式：`+ 3 * 5 8 `
- 中缀表达式（infix expression）：运算符位于操作数之间
   - 简单形式：`3 + 5`
   - 复杂形式：`3 + 5 * 8`
- 后缀表达式（postfix expression）：运算符位于操作数之后（逆波兰式）
   - 简单形式：`3 5 +`
   - 复杂形式：`5 8 * 3 +`
- 前缀表达式和后缀表达式的解析和求值，只需要栈即可完成。
- 中缀表达式可转换为前缀表达式或后缀表达式再行求值；亦可解析为求值二叉树再后序遍历求值。

	
#### 前缀表达式的求值

- 算法描述：
  1. 创建一个空的操作数栈 `operands`。
  1. 从右至左扫描表达式，分解出词元（token）。
  1. 若词元为数值，则将数值压入 `operands`；若词元为运算符，则从 `operands` 弹出两个数值，用当前运算符对它们做相应的计算（`先弹出的数值作为运算符左操作数，后弹出的数值作为运算符右操作数`），然后将结果压入 `operands`。
  1. 重复上述过程直到表达式中的词元全部处理完成；`operands` 栈顶的数值即为该表达式的求值结果。
- 例如：`- × + 3 4 5 6`
  1. 从右至左扫描，依次将 `6`、`5`、`4`、`3` 压入 `operands`。
  1. 其后是 `+` 运算符，从 `operands` 中依次弹出 `3` 和 `4`，计算 `3 + 4`，得 `7`，再将 `7` 压入 `operands`。
  1. 其后是 `×` 运算符，从 `operands` 中依次弹出 `7` 和 `5`，计算 `7 × 5`，得 `35`，将 `35` 压入 `operands`。
  1. 其后是 `-` 运算符，从 `operands` 中依次弹出 `35` 和 `6`，计算 `35 - 6`，得 `29`，将 `29` 压入 `operands`。
  1. 表达式扫描完成，取出栈顶数值 `29`，得出表达式的求值结果为 `29`。

	
#### 后缀表达式的求值

- 算法描述：
  1. 创建一个空的操作数栈 `operands`。
  1. 从左到右扫描表达式，分解出词元。
  1. 若词元为数值，则将数值压入`operands`；若词元为运算符，则从 `operands` 弹出两个数值，用当前运算符对它们做相应的计算（`先弹出的数值作为运算符右操作数，后弹出的数值作为运算符左操作数`），然后将结果压入`operands`。
  1. 重复上述过程直到表达式全部处理完成；`operands` 栈顶数值即为该表达式的求值结果。
- 例如：`3 4 + 5 × 6 -`
  1. 将数值 `3`、`4` 压入栈。
  1. 其后是 `+` 运算符，从 `operands` 中依次弹出 `3` 和 `4`，计算 `4 + 3`，得 `7`，再将 `7` 压入 `operands`。
  1. 其后是数值 `5`，压入 `operands`。
  1. 其后是 `×` 运算符，从 `operands` 中依次弹出 `5` 和 `7`，计算 `7 × 5`，得 `35`，将 `35` 压入 `operands`。
  1. 其后是数值 `6`，压入 `operands`。
  1. 其后是 `-` 运算符，从 `operands` 中依次弹出 `6` 和 `35`，计算 `35 - 6`，得 `29`，将 `29` 压入 `operands`。
  1. 表达式扫描完成，取出栈顶数值 `29`，得出表达式的求值结果为 `29`。

	
#### 中缀表达式转换为前缀表达式

- 算法描述：
  1. 初始化两个栈：运算符栈 `operators` 和结果的栈 `result`。
  1. 从右至左扫描中缀表达式，分解出词元。
  1. 当词元为操作数时，将其压入 `result`。
  1. 当词元为运算符时，比较其与 `operators` 栈顶运算符的优先级。
     1. 如果 `operators` 为空，或栈顶运算符为右括号 `)`，则直接将此运算符入栈；
     1. 否则，若该运算符的优先级比栈顶运算符`高或相等`，将该运算符压入 `operators`；
     1. 否则，将 `operators` 栈顶的运算符弹出并压入到 `result` 中，并转到步骤 4.1。
  1. 遇到括号时，
     1. 如果是右括号 `)`，则直接压入 `operators`。
     1. 如果是左括号 `(`，则依次弹出 `operators` 栈顶的运算符，并压入 `result`，直到遇到右括号为止，此时将这一对括号丢弃。
  1. 重复步骤2，直到表达式的最左边。
  1. 将 `operators` 中剩余的运算符依次弹出并压入 `result`。
  1. 依次弹出 `result` 中的元素并输出，结果即为中缀表达式对应的前缀表达式。

	
- 举例：将中缀表达式 `a+((b+c)×d)-e` 转换为前缀表达式

| 词元  | `result`                  | `operators`       | 说明                                          |
| ---   | ---                       | ---               | ---                                           |
| e     | e                         | EMPTY             | 数值，压入 `results` 栈                       |
| -     | e                         | -                 | 运算符，`operators` 为空，直接入栈            |
| )     | e                         | ), -              | 右括号，压入 `operators` 栈                   |
| d     | d, e                      | ), -              | 数值，压入 `results` 栈                       |
| ×     | d, e                      | ×, ), -           | `operators` 栈顶是右括号，直接入栈            |
| )     | d, e                      | ), ×, ), -        | 右括号，压入 `operators` 栈                   |
| c     | c, d, e                   | ), ×, ), -        | 数值，压入 `results` 栈                       |
| +     | c, d, e                   | +, ), ×, ), -     | `operators` 栈顶是右括号，直接入栈            |
| b     | b, c, d, e                | ), ×, ), -        | 数值，压入 `results` 栈                       |
| (     | + b, c, d, e              | ×, ), -           | 左括号，弹出运算符直至遇到右括号              |
| (     | ×, + b, c, d, e           | -                 | 左括号，从`operators`弹出运算符并压入`result`直至遇到右括号 |
| +     | ×, + b, c, d, e           | +, -              | 优先级与栈顶的 `-` 相同，直接入栈             |
| a     | a, ×, + b, c, d, e        | +, -              | 数值，压入 `results` 栈                       |
| NONE  | -, +, a, ×, + b, c, d, e  | EMPTY             | 从 `operators` 弹出所有运算符并压入 `result`  |

	
#### 中缀表达式转换为后缀表达式

- 算法描述：
  1. 初始化两个栈：运算符栈 `operators` 和结果栈 `result`。
  1. 从左至右扫描中缀表达式，分解出词元
  1. 当词元为操作数时，将其压入 `result`。
  1. 党词元为运算符时，比较其与 `operators` 栈顶运算符的优先级：
     1. 如果 `operators` 为空，或栈顶运算符为左括号 `(`，则直接将此运算符入栈；
     1. 否则，若该运算符的优先级比栈顶运算符`高`，将该运算符压入 `operators`；
     1. 否则，将 `operators` 栈顶的运算符弹出并压入到 `result` 中，并转到步骤 4.1。
  1. 遇到括号时，
     1. 如果是左括号 `(`，则直接压入 `operators`；
     1. 如果是右括号 `)`，则依次弹出 `operators` 栈顶的运算符，并压入 `result`，直到遇到左括号为止，此时将这一对括号丢弃。
  1. 重复步骤2，直到表达式的最右边；
  1. 将 `operators` 中剩余的运算符依次弹出并压入 `result`；
  1. 依次弹出 `result` 中的元素并输出，其结果的`逆序`即为中缀表达式对应的后缀表达式。

	
- 举例：将中缀表达式 `a+((b+c)×d)-e` 转换为后缀表达式

| 词元  | `result`                  | `operators`    | 说明                                          |
| ---   | ---                       | ---               | ---                                           |
| a     | a                         | EMPTY             | 数值，压入 `results` 栈                       |
| +     | a                         | +                 | 运算符，`operators` 为空，直接入栈            |
| (     | a                         | (, +              | 左括号，压入 `operators` 栈                   |
| (     | a                         | (, (, +           | 左括号，压入 `operators` 栈                   |
| b     | b, a                      | (, (, +           | 数值，压入 `results` 栈                       |
| +     | b, a                      | +, (, (, +        | `operators` 栈顶是左括号，直接入栈            |
| c     | c, b, a                   | +, (, (, +        | 数值，压入 `results` 栈                       |
| )     | +, c, b, a                | (, +              | 右括号，弹出运算符压入`result`直至遇到左括号  |
| ×     | +, c, b, a                | ×, (, +           | `operators` 栈顶是左括号，直接入栈            |
| d     | d, + c, b, a              | ×, ), +           | 数值，压入 `results` 栈                       |
| )     | ×, d, + c, b, a           | +                 | 右括号，弹出运算符压入`result`直至遇到左括号  |
| -     | +, ×, d, + c, b, a        | -                 | 优先级与栈顶的 + 相同，先弹出 + 并压入`result`，再压入 -  |
| e     | e, +, ×, d, + c, b, a     | -                 | 数值，压入 `results` 栈                       |
| NONE  | -, e, +, ×, d, + c, b, a  | EMPTY             | 从 `operators` 弹出所有运算符并压入 `result`  |

		
## 将中缀表达式解析为求值二叉树

- 原理
   1. 单个双目算术运算，可构成一个以操作数为叶子节点，结果为根节点的二叉树。
   1. 有多个运算符参与的混合运算，按优先级或者括号递归处理，然后将这些二叉树铰接在一起；如果某个二叉树的根将作为另一个运算二叉树的操作数，则将其铰接（splice）到那个二叉树上，成为其子节点。此时，括号、前后两个运算符的优先级，将决定如何铰接两个二叉树。
   1. 通过后序遍历求出所有内部节点的值，结束后根节点的值即为表达式的最终求值结果。

	
- 举例
  1. `3 + 5`
  1. `3 + 5 - 6`
  1. `3 + (5 - 6)`
  1. `3 + (5 - 6) × 6`
  1. `[3 + (5 - 6) × 6] ÷ [4 × (3 - 8)]`

		
## 综合练习：算术表达式解析器

`Arithmetic expression parser`

	
编写一个算术表达式解析器（`arithmetic-expression-parser.cpp`）完成中缀表达式的解析和求值。

- 要求支持如下功能：
  1. 读取用户输入的中缀算术表达式；该表达式支持加减乘除四则混合运算，支持负号、括号。
  1. 将中缀表达式转换为前缀表达式进行求值，输出前缀表达式及其求值结果。
  1. 将中缀表达式转换为后缀表达式进行求值，输出后缀表达式及其求值结果。
  1. 将中缀表达式解析为求值二叉树进行求值，按求值二叉树输出其正规中缀表达式（全部使用括号表示运算顺序）及其求值结果。
  1. 若发现表达式有误，输出 `INVALID`。

	
- 运行效果如下：

```console
$ ./arithmetic-expression-parser
<300.5 + 50.6>  // 注意：运算符和操作数之间可能包括任意多的空白字符。
Prefix expression: + 300.5 50.6
    = 351.1
Postfix expression: 50.6 300.5 +
    = 351.1
Normalized infix expression: (300.5 + 50.6)
    = 351.1

$ ./arithmetic-expression-parser
<300.5 + ((5 + 10.6) * 85>
INVALID
```

	
### 实现解析器时要考虑的问题

- 假定表达式使用十进制表示实数或整数，表达式支持 `+`、`-`、`*`、`/` 四则运算以及 `()`，且不含非法字符。注意若数值为整数，还可以支持 `%` 运算。
- 如何处理负号（`-`）？
  1. 前缀和后缀表达式无法有效识别负号和减号。有两种解决办法：可将负号转为减法运算，比如 `-5`，对应 `0 - 5`；或者始终在运算符和操作数之间插入至少一个空白字符，而负号和数字之间不插入任何空白字符。
  1. 中缀表达式中，可通过上下文判断是否为负号，比如 `-3 + -5`，或者 `(-3) + (-5)`。
- 如何判断非法表达式？
  1. 前缀和后缀表达式的处理中，在执行运算时，若操作数栈中只有一个操作数，则对应表达式为非法。
  1. 将中缀表达式转换为前缀或后缀表达式时，若出现括号不匹配的情形，则表达式为非法。
  1. 将中缀表达式解析为求值二叉树时，若出现括号不匹配的情形，或者没有预期的操作数时，则表达式为非法。
- 如何判断表达式中括号的嵌套关系？
  1. 参考中缀表达式转前缀表达式的算法，使用栈来跟踪括号。

		
## 实用技巧及工具

`Skills and Utilities`

	
### C++ STL 字符串转换接口（函数模板）

| 函数      | 用途 |
| ---       | ---  |
| `stoi`    | 字符串转换为整数（int）                           |
| `stol`    | 字符串转换为长整型（long）                        |
| `stoul`   | 字符串转换为无符号整型（unsigned long）           |
| `stoll`   | 字符串转换为长长整型（long long）                 |
| `stoull`  | 字符串转换为无符号长长整型（unsigned long long）  |
| `stof`    | 字符串转换为单精度浮点数（float）                 |
| `stod`    | 字符串转换为双精度浮点数（double）                |
| `stold`   | 字符串转换为长双精度浮点数（long double）         |

	
- 原型及用法（`stol` 为例）

```cpp
#include <string>

long stol(const string& str, size_t* idx = 0, int base = 10);

    std::string str_bad = "xyz";
    std::string str_dec = "1987520";
    std::string str_hex = "2f04e009";
    std::string str_bin = "-11101001100100111010";
    std::string str_auto = "0x7fffff";

    std::string::size_type sz;   // alias of size_t

    long li_bad = std::stol(str_bad, &sz);      // sz = 0; li_bad = 0;
    long li_dec = std::stol(str_dec, &sz);
    long li_hex = std::stol(str_hex, nullptr, 16);
    long li_bin = std::stol(str_bin, nullptr, 2);
    long li_auto = std::stol(str_auto, nullptr, 0);
```

- 参数说明
  1. `str`：用于表达一个数值的字符串对象。
  1. `idx`：如果 `idx` 不是空指针，则该函数会将 `idx` 的值设置为 `str` 中合法数值后的第一个字符的索引。
  1. `base`：决定有效字符及其解释的数字基数（进制）。如果此值为 `0`，则使用的进制由字符串序列的格式决定（如 `0x` 前缀表示 16 进制）。注意此参数的默认值为为 `10`，而不是 `0`。

	
### C 字符串转换接口

| 函数      | 用途 |
| ---       | ---  |
| `atoi`    | 字符串转换为整数（int）                   |
| `strtol`  | 字符串转换为长整型（long）                |
| `strtoul` | 字符串转换为无符号整型（long long）       |
| `strtoll` | 字符串转换为长长整型（long long）         |
| `strtoull`| 字符串转换为无符号长长整型（unsigned long long）|
| `strtof`  | 字符串转换为单精度浮点数（float）         |
| `strtod`  | 字符串转换为双精度浮点数（double）        |
| `strtold` | 字符串转换为长双精度浮点数（long double） |

	
- 原型及用法示例

```cpp
#include <cstdlib>

int atoi(const char* str);
long int strtol(const char* str, char** endptr, int base);
long double strtold(const char* str, char** endptr);

  char reals[] = "90613.305 365.24";
  char* end;

  long double f1, f2;
  f1 = strtold(reals, &end);
  f2 = strtold(end, NULL);
```

